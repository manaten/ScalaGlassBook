# 抽象メンバー

## キーワード
- 抽象型
- 抽象val
- 抽象var
- 事前初期化済みフィールド
- 遅延評価


# 弾丸ツアー
```scala
trait Abstract {
  type T
  def transform(x: T): T
  def initial: T
  def current: T
}

class Concrete extends Abstract {
  type T = String
  def transform(x: String) = x + x
  val initial = "hi"
  val current = initial
}
```

# 型メンバー
抽象型とは、```type T```のように、定義のないtype宣言であり、クラスやトレイトのメンバーとして属する。

具象的なtype宣言は、型に別名を与える手段である。```type T = String```はStringにTという別名を与えている。Concrete中でのTはStringと同じ意味である。

型メンバーは、長いクラス名を短くするためと、前節のように抽象型の宣言に用いる。

# 抽象val
抽象val宣言は、以下のように値の定義のないval宣言である。
サブクラスで具象定義を与える必要がある。

```scala
val initial: String
```

抽象val宣言はパラメータのない抽象def宣言と似ているが、def宣言はメソッド宣言なので返す値は変わりうるが、val宣言ではそのようなことはない。つまり、パラメータのない抽象def宣言と比べて制約を増やしたものが抽象val宣言であるといえる。次のように、パラメータのない抽象def宣言をオーバーライドして抽象val宣言にすることができる(逆はできない)。

```scala
abstract class Fruit {
  val v: String
  def m: String
}

abstract class Apple extends Fruit {
  val v: String
  val m: String // これはできる
}

abstract class BadApple extends Fruit {
  def v: String // これは無理
  def m: String
}
```

# 抽象var
抽象var宣言は、抽象val宣言と同じく、名前だけ定義して初期値を与えていないものである。

公開されたvar宣言は、18.2節で説明された(やってない)とおりに自動でゲッター・セッターを作る。
抽象宣言でも同じであり、hourという抽象var宣言を作ることは、```hour```というゲッターと```hour_=```というセッターを定義するのと等しい。ただし、代入される実態は具象化したクラスに属する。

# 抽象valの初期化

抽象valはスーパークラスで定義されていない詳細をサブクラスで定義させるため、スーパークラスのパラメータと似た役割を果たすことがある。

次のようなトレイトは、**無名クラス**として次のようにインスタンス化できる。
```scala
trait RationalTrait {
  val numerArg: Int
  val denomArg: Int
}

// 無名クラスとしてインスタンス化
new RationalTrait {
  val numerArg = 1
  val denomArg = 2
}
```

このようにすると、普通のクラスのインスタンス化```new Rational(expr1, expr2)``` と大体一緒の効果が得られる。違いは、引数expr1,expr2の評価タイミングである。

```new Rational(expr1, expr2)``` では引数の評価はRationalの初期化の前に行われる(式の実行順序的にも直感的だと思う)。

対して、
```scala
new RationalTrait {
  val numerArg = expr1
  val denomArg = expr2
}
```
では、expr1, expr2(サブクラスのフィールド)の評価は RationalTrait(スーパークラスのコンストラクタ) の初期化の後にされる(クラスの定義の実行順序的な)。
なので、もしRationalTraitの初期化にこれらの値を利用していると、予期しない結果になりうる。

## 事前初期化済みフィールド
スーパークラスが呼び出される前にサブクラスのフィールドを初期化する仕組み。

```scala
// 無名クラスの場合
new {
  val numerArg = 2
  val denomArg = 3
} with RationalTrait

// オブジェクト定義の場合
object twoThirds extends {
  val numerArg = 2
  val denomArg = 3
} with RationalTrait

// クラス定義の場合
class RationalClass(n: Int, d: Int) extends {
  val numerArg = n
  val denomArg = d
} with RationalTrait {
  ...
}
```

これらはクラス初期化前に実行されるので、thisを参照することはできない。
```scala
new {
  val numerArg = 2
  val denomArg = this.numerArg * 2 // エラー
} with RationalTrait
```

## 遅延評価val
前節のように人間が頑張るのではなく、システムに初期化順序を考えさせたい場合がある。
val定義を**遅延評価**させることで可能になる。val定義にlazy修飾子をつけることで、遅延評価されるようになる。

```scala
object Demo {
  val x = { println("initializing x"); "done" }
}

Demo // ここで initializing x
Demo.x
```

```scala
object Demo {
  lazy val x = { println("initializing x"); "done" }
}

Demo
Demo.x // ここで initializing x
```

xの初期化が必要になった時初めてなされる。なお、二回xを呼んでも二回実行されるような事にはならない。

本の例では、遅延評価を使うことで、プログラマが必要なときに必要なフィールドが全て初期化されているように実行順序を考える作業から開放されるとしている。
この遅延評価のメリットは、プログラムが副作用のない関数型的に書かれていてもたらされるものであり、副作用があると順番が大事になってしまうので、命令型のプログラムには遅延評価は適していない。

# 抽象型

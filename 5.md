# 基本型と演算子

## この章のキーワード

- 基本型
  - 整数値型
  - 数値型
- リテラル
  - シンボルリテラル
- 演算子はメソッド
  - オーバーロード
  - 単項演算子
  - 後置演算子
- 演算子いろいろ
  - 算術演算
  - 関係演算子・論理演算子
    - 短路, 名前渡しパラメータ
  - ビット単位演算子
- オブジェクトの等価性
- 演算子の優先順位と統合性
  - メソッド名による優先順位決定
  - 代入演算子
  - 演算子の結合性
- リッチラッパー
  - 暗黙型変換



## 基本型

- 数値型 = (Byte, Short, Int, Long, Char)
- 整数型 = 数値型 ++ (Froat, Double)

## リテラル
リテラルは、コード中に記述可能な即値。

### 整数のリテラル
Int, Longのリテラル

```scala
val hex = 0x5
val magic = 0xDeadBeef

val oct = 035

val dec = 31

val long = 35L
```

Intのリテラルは、範囲が収まっていればShort、Byteに代入可能
```scala
val little: Short = 367
val littler: Byte = 38
```

### 浮動小数点のリテラル
小数点を保つ場合、または指数部を保つ場合。
末尾にFがつかない場合はDoubleのリテラル。
```scala
val big = 1.2345
val bigger = 1.2345e1
val biggerStill = 123E45

val float = 1.2345F
```

### 文字リテラル

```scala
val a = 'A'
val c = '\101'
val d = '\u0041'
val backslash = '\\'
```

### 文字列リテラル
```scala
val hello = "hello"
val longStr = """hogehoge
hogehoge"""
```

ヒアドキュメントでインデントしたい場合
```scala
val longStr = """|hogehoge
                 |hogehoge""".stripMargin
```

### シンボルリテラル
```scala
val s = 'aSymbol
```

シンボルは、プログラム中で同名のものはひとつしか存在しない。
ハッシュのキーなど、唯一の概念を表したいときに用いる。

### Boolean リテラル
```scala
val bool = true
val fool = false
```

## 演算子はメソッド
```scala
val sum = 1 + 2
```
としたとき、
```scala
val sum = (1) .+ (2)
```
とおなじであり、 + 演算子は + という名前のメソッドにすぎない

### オーバーロード
```scala
val sum = 1 + 2L
```
としたとき、Longを引数に取る方の +演算子が呼び出される。
(このあたりはPHPずっとやってるとすごい大事で、よくわからない型変換が行われるわけでなく(暗黙型変換はあるが)、
しっかりメソッドとして定義されたものが呼ばれる。ちゃんとリファレンスに書いてあるということ。)

### 中置記法
+だけでなく、すべてのメソッドがこの記法で記述可能
```scala
"Hello, World" indexOf 'o'
"Hello, World" indexOf ('o', 5) // 二引数以上の場合
```

### 単項演算子
```-2.0``` の ```-``` もメソッド。
unary_ というプレフィックスを付けたメソッドは単項演算子形式で呼びだせる。
```scala
-2.0
(2.0).unary_-
```

ただし、前置で呼び出せるのは ```+,-,!,~``` のみ。

### 後置演算子
scalaでは空括弧は省略可能。
```scala
s.toLowerCase
```

さらに、ドットも省略して後置演算式法になる

```scala
s toLowerCase
```

## 演算子いろいろ
Scalaの演算子は、メソッドなので、型のリファレンスを見れば載ってる。

### 算術演算
```scala
1.2 + 1.3
3 - 1
'b' - 'a'
2L * 3L
11 / 4
11 % 4
11.0f / 4.0f
11.0 % 4.0
```
ただし、剰余は整数の演算なので、IEEE754の剰余が欲しい場合は、 ```Math.IEEEremainder```を使う。

#### 単項演算子
```scala
-2
+3
```

### 関係演算子・論理演算子
```scala
1 > 2
1 < 2
1.0 <= 1.0
3.5f >= 3.6f
'a' >= 'A'
!true
```

```scala
val toBe =true
val question = toBe || !toBe
val paradox  = toBe && !toBe
```

#### 短路, 名前渡しパラメータ
```||, &&```はよく知られているものと同じく、短路的に終わる場合がある。
例えば、```true || hoge()```のような場合、```hoge()```は評価されない。

演算子はメソッドなのに短路をどう実装しているかは、名前渡しパラメータを用いて実装しているためである。(9.5章)

### ビット演算
```scala
1 & 2
1 | 2
1 ^ 3
~1

-1 >> 31
-1 >>> 31
1 << 2
```

## オブジェクトの等価性
```==, !=```を用いる。
```scala
1 == 2
1 != 2
2 == 2

// 基本型以外
List(1,2,3) === List(1,2,3)

// 異なる型
1 == 1.0
List(1,2,3) == "Hello"

// null比較
List(1,2,3) == null
null == List(1,2,3)
```

== は等価かどうかだけを比較するよう作られている。
左辺がnullかどうかをチェックし、nullでなければ左辺のequalsメソッドを呼び出す。
(equalsがちゃんと実装されていれば、意味や内容に基づいた比較も==でされる。Javaではポインタが同じかどうかしか見てないので、苦しめられた。
equalsの定義次第で、他のオブジェクトとの比較もできるということ。)


## 演算子の優先順位と統合性
演算子=メソッドという設計は利便だが、演算子が避けては通れない優先順位の問題(ややしがらみ感)。
scalaでは、演算子の先頭文字により優先順位が決定。
ただし、末尾が=で終わる代入演算子のばあいは、優先順位が最低になる。

優先順位が同じ演算子が並ぶ場合は、演算子の結合性によって結合順が決まる。
結合順は、末尾の文字によって決まる。

(基本的に一般的な言語と同じ優先・結合するようだが、まあよくわかんなかったら、正しく結合するように括弧で囲めというお話。)

## リッチラッパー
型メソッド以外にも多くのメソッドが有る。
前にちょっと触れたRichStringのような、**暗黙型変換**により提供される追加メソッド。
リッチラッパーと呼ばれる。

例えば、
```scala
0 max 5
0 min 5
-2.7 abs
-2.7 round
(1.0 / 0) isInfinity
4 to 6
"bob" capitalize
"robert" drop 2
```
などがリッチラッパーにより提供される
(前知識として持っておかないと、メソッドの宣言が見つけられなくて苦労するかもくらいの認識。
基本型のメソッドが増えすぎないので、よい設計だと思う)

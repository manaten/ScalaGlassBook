# 暗黙の型変換とパラメーター

## キーワード

# 暗黙の型変換

例:RandomAccessSeq[T]トレイト。T型のランダムアクセス可能なシーケンスを表し、それによって可能なtake, drop, map, filter, exists, mkStringなどのメソッドを持つ。抽象メソッドであるlengthとapplyを実装すれば、これらが利用可能になる。

ここで、既存のクラスをRandomAccessSeqに対応させることを考える。
たとえば、Java.lang.Stringは明らかにRandomAccessSeq[Char]の性質を持つが、トレイトをミックスインして作られていない。

このようなときに、以下の様な暗黙型変換メソッドを定義してやれば良い。
```scala
implicit def stringWrapper(s: String) =
  new RandomAccessSeq[Char] {
    def length = s.length
    def apply(i: Int) = s.charAt(i)
  }
}
```
次のように、明示的に呼び出せば当然StringからRandomAccessSeqのインスタンスは得られる。
```scala
stringWrapper("abc123") exists(_.isDigit) // true
```

が、呼びださなくても暗黙的に呼び出されて、同じ動作をする。
```scala
"abc123" exists(_.isDigit) // true
```

コンパイラが自動で先のコードに変換しているのだが、まるでJavaのStringが追加メソッドを手に入れたようにみえる。

これはC#の拡張メソッドに似ているが、implicitでは、既存のトレイトの抽象メソッドの実装という最小限の操作でたくさんのメソッドを追加できる。

暗黙型変換では、ターゲット型への変換も可能である。
```scala
def printWithSpaces(seq: RandomAccessSeq[Char]) =
  seq mkString " "

printWith("xyz")
```


# implicitの規則
暗黙型変換は、```x + y```がコンパイラを通らない時に、```convert(x) + y```に変換してコンパイルを試みる。
暗黙型変換は、次の一般原則によって管理されている。

## マーキングルール: implicitによって修飾された定義だけが暗黙の型変換に使われる
```scala
implicit def intToString(x: Int) = x.toString
```

それ以外の定義が利用されたりしたら混乱する。当然の規則。

## スコープルール:挿入される暗黙の型変換は、単一の識別子としてスコープ内にあるか、変換のソース型やターゲット型と対応付けられていなければならない

### 単一の識別子
スコープから```someVariable.convert```という形ではなく、```convert```と言う形で見えないとダメ。そうなってない場合はimportする必要がある。
ライブラリで役に立つ暗黙型変換をPreambleオブジェクトに用意することが多く、それらは```Preamble._```ですべて利用可能になる。


### ソース型やターゲット型のコンパニオンオブジェクト
単一識別子ルールの例外で、ソース型(変換前の型)やターゲット型(要求された変換後の型)のコンパニオンオブジェクトのimplicit定義も暗黙型変換の検索対象になる。

```scala
object Doller {
    implicit def dollarToEuro(x: Dollar): Euro ...
}
class Doller { ... }
```
このような場合、dollarToEuroはDollarに**関連づいている**という。

このルールによって、気にしないといけないのはインポートされているものと、明示的に参照している型のみになる。
もし、これがプログラム全体だと、すべての暗黙型変換を把握することが必要になってしまう。

## あいまい回避ルール:暗黙の型変換は他に挿入すべき変換がないときに限って挿入する
```x + y```を暗黙型変換するメソッドが二種類あり、```convert1(x) + y``` ```convert2(x) + y```のどちらにも変換が可能な場合、コンパイラは暗黙型変換しない。
このような場合、片方をスコープから見えなくするか、明示的に ```convert1(x) + y``` とかくしか無い。

## 一度に一回ルール:  暗黙の型変換は一度しか実行されない
コンパイラが ```x + y``` を ```convert1(convert2(x)) + y``` に変換することは決してしない。
やり過ぎると実際のコードと剥離してしまうため。

## 明示的変換優先ルール: 書かれたままのコードで型チェックをパスする時は、暗黙の型変換を行わない。
既に動くコードは暗黙型変換しない。

## 暗黙型変換の名前の付け方
暗黙型変換の名前は、明示的に利用する場合と任意の位置で使える暗黙の型変換を指定するときのみに意味がある。

## 暗黙の型変換が試される場所
暗黙型変換が使われる場所は、要求された型への変換、レシーバーの変換、暗黙のパラメーターの3つ。



# ケースクラスとパターンマッチ

## キーワード
- ケースクラス
- パターンマッチ
  - 定数パターン
  - 変数パターン
  - ワイルドカードパターン
  - コンストラクターパターン

# ケースクラス
```case class``` キーワードで書き始めるクラスを **ケースクラス** と呼ぶ。
ケースクラスは後述するパターンマッチを利用するときに便利な、データ型をScalaで表示するための機構である。

変数、数値、単項演算、二項演算からなる算術式をケースクラスで表す。

```scala
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String, left: Expr, right: Expr) extends Expr
```

## ケースクラスの特徴
ケースクラスでは、コンパイラが様々な変更を加える。

### クラスと同名のファクトリメソッドの追加
```scala
// new Var("x") としなくてよい
val v = Var("x")
val op = BinOp("+", Number(1), v)
```

### パラメータの暗黙的なval化
すべてのパラメータはそのままフィールドとして利用可能。

```scala
v.name
op.left
```

### toString, hashCode, equalsの自然な実装の追加
```scala
pintln(op)
// BinOp(+, Number(1.0), Var(x))
op.right == Var("x")
// true
```

## パターンマッチ
上で定義した数式に単純化のルールを盛り込むことを考える。

例えば、
- 負の負はもとのまま
- 0の加算はもとのまま
- 1の乗算はもとのまま

パターンマッチを用いると、以下のように記述できる。

```scala
def simplifyTop(expr: Expr): Expr = expr match {
  case UnOp("-", UnOp("-", e))  => e // 負の負はもとのまま
  case BinOp("+", e, Number(0)) => e // 0の加算はもとのまま
  case BinOp("*", e, Number(1)) => e // 1の乗算はもとのまま
  case _                        => expr
}
```

この関数は以下のように使う。
```scala
simplifyTop(UnOp("-", UnOp("-", Var("x"))))
// Expr = Var(x)
```

パターンマッチでは、match式の中に複数の **選択肢** を記述する。
選択肢は、caseキーワードから始まり、パターンと、マッチした場合に評価する式を ```=>``` でつないで記述する。
最初にマッチしたパターンが実行される。

パターンには以下の様な種類がある。

### 定数パターン
```"+"```, ```1``` などの定数リテラル。単に ```==```で比較し、等しい場合はマッチする。

### 変数パターン
```e``` などの変数はすべての値とマッチし、右辺で束縛され参照可能である。

### ワイルドカードパターン
```_``` と記述した場合もすべての値とマッチするが、変数束縛はされない。

### コンストラクターパターン
```UnOp("-", e)``` のような形。
この例では、第一引数が ```"-"```, 第二引数が ```e``` にマッチするすべての UnOp型にマッチする。
コンストラクターの引数のパターンとなっている(再帰的なパターンマッチをしている)。

複雑なパターンマッチの例。

```scala
UnOp("-", UnOp("-", e))
```

## matchとswitchの違い
matchはJavaやPHPのswitchを一般化したものと考えられる。
swicthはすべてのパターンが定数であり、最後のパターンがワイルドカードであると考えると、match式での記述が可能である。

ただし、
- matchは式であり、必ず値を返す
- Scalaの選択肢式は、switchのように、続けて落ちて実行はされない
- マッチするパターンがない場合、MatchErrorという例外が発生する

マッチするパターンがない場合は上記のようにエラーとなるので、何もしないデフォルトケースであってもすべてのケースがカバーされ無くてはならない。

```scala
expr match {
  case BinOp(op, left, right) =>
    println(expr + "is a binary operation")
  case _ =>
}
```
上の例だと、BinOp以外のすべてのexpr式に対して、第二のケースが実行され、```()``` が返却される。

# パターンの種類


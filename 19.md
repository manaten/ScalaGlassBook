# 型のパラメータ化

## キーワード
- 完全永続
- 情報隠蔽
- 型コンストラクタ
- ジェネリック
- 変位指定アノテーション
  - 共変
  - 非変
  - 反変

# 関数型待ち行列

関数型待ち行列は次の3つの操作を持つデータ構造。
- head 先頭要素を取得
= tail 先頭を取り除いた残りのキューを取得
- append 末尾に要素追加

次のようなQueueクラスを作りたい。

```scala
q = Queue(1, 2, 3)
val q1 = q append 4
q // Queue(1, 2, 3)
```

リストと同じく、Queueは**完全永続**であり、もとの```q```はappend呼び出し後も変化しない。

リストと同じく、head, tail はあるが、要素が先頭ではなく末尾に追加される。head, tail, appendは定数時間で終わるようにしたい。このようなデータ構造をどう作ればいいか。

単純な表現型としてリストを使う実装(appendの効率が悪い)。

```scala
class SlowAppendQueue[T](elems: List[T]) {
  def head = elems.head
  def tail = new SlowAppendQueue(elems.tail)
  def append(x: T) = new SlowAppendQueue(elems ::: List(x))
}
```

appendを高速にするアイデアとして、リストをひっくり返して使う方法が考えられる(こんどはheadとtailが遅くなってしまう)。

```scala
class SlowHeadQueue[T](smele: List[T]) {
  def head = smele.last
  def tail = new SlowHeadQueue(smele.init)
  def append(x: T) = new SlowHeadQueue(x :: smele)
}
```

高速なQueueを実装するために、2つのアイデアを組み合わせる。

```scala
class Queue[T] (
  private val leading: List[T],
  private val trailing: List[T]
) {
  private def mirror =
    if (leading.isEmpty)
      new Queue(trailing.reverse, Nil)
    else
      this
  def head = mirror.leading.head
  def tail = {
    val q = mirror
    new Queue(q.leading.tail, q.trailing)
  }
  def append(x: T) = new Queue(leading, x :: trailing)
}
```

Queueの前半をleading, 後半を反転したものをtrailingとし、appendはtrailingの先頭に追加(高速)。
headとtailはleadingのheadとtailを利用(高速)。
leadingが空になった場合だけ、mirrorでtrailing.reverseを新たなleadingとしてあげる。

head, tail, appendがそれぞれ同じ回数だけ呼ばれると仮定すれば、どのメソッドの計算量も一定とみなせる。
leadingが空になるのはtailをn回呼び出した後であり、その時trailingの要素数=appendした回数もn回なので、appendのコストが倍になったとみなすことができるため。
ただし、例えばheadだけたくさん呼ばれる場合などは、この議論は破綻する。

# 情報隠蔽
前節のQueueは高速で優れた実装であるが、コンストラクタでパラメータとして謎のList2つを取る点がイケていない。クライアントにうまく隠したい(**情報隠蔽**)。

## 非公開コンストラクタとファクトリメソッド

private修飾子を付けて、コンストラクタを外部から非公開にできる。
こうすることで、外部からQueueのコンストラクタは利用できなくなる。
```scala
class Queue[T] private (
  private val leading: List[T],
  private val trailing: List[T]
)
```

クライアントコードからQueueのコンストラクタを呼び出す方法が必要であり、例えば補助コンストラクタを作る方法がある。```T*``` は、T型の連続パラメータである(8.8節)。

```scala
def this() = this(Nil, Nil) // 空のキューを作る用
def this(elems: T*) = this(elems.toList, Nil) // 要素ありの状態で初期化する用
```

もしくは、コンパニオンオブジェクトから非公開コンストラクタにアクセスできるので、ファクトリメソッドを作ってあげる方法もある。ファクトリメソッドの名前が```apply```なので、```Queue(1, 2, 3)```という形式で利用できる。

```scala
object Queue {
  def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
}
```

## 非公開クラスを使う方法

クラスの公開インタフェースのみをトレイトとし、実装を非公開クラスにする方法もある。

```scala
// インタフェースのみ公開
trait Queue[T] {
  def head: T
  def tail: Queue[T]
  def append(x: T): Queue[T]
}

object Queue {
  // 内部クラスをQueueとして外部に見せる
  def apply[T](xs: T*): Queue[T] =
    new QueueImpl[T](xs.toList, Nil)

  // 内部クラスでprivateをつけ、非公開クラスとする。
  private class QueueImpl[T] (
    private val leading: List[T],
    private val trailing: List[T]
  ) extends Queue[T] {
    private def mirror =
      if (leading.isEmpty)
        new QueueImpl(trailing.reverse, Nil)
      else
        this
    def head = mirror.leading.head
    def tail = {
      val q = mirror
      new QueueImpl(q.leading.tail, q.trailing)
    }
    def append(x: T) = new QueueImpl(leading, x :: trailing)
  }

}
```

## 変異指定アノテーション
上記で作ったQueueはトレイトであり型ではない。型パラメータをともなっているため、Queue単体では型ではなく、Queue型の変数は作れない。パラメータを伴うことではじめて型となる。
```scala
def hoge(q: Queue) {} // これはだめ
def fuga(q: Queue[AnyRef]) {} // これはOK
```

QueueはトレイトだがQueue[String]は型。Queueはパラメータを伴えば型を作れるので、**型コンストラクタ** と呼ぶ(Queue[Int], Queue[String]などの型を作る)。

Queueは **ジェネリックトレイト** とも考えられる(型パラメータをとれる状態ではジェネリックだが、パラメータをとったあとは特化型である)。

ここで一つ問題がある。Queue[T]から生成された、Queue[String]はQueue[AnyRef]のサブ型なのだろうか。
もしそうであるならば、QueueトレイトはパラメータTについて**共変**であるという。その場合、Queue[AnyRef]の引数を取る関数にQueue[String]を渡すことができる。

Scalaではジェネリック型のサブ型はデフォルトでは**非変**であり、Queue[String]とQueue[AnyRef]の間には親子関係はない。しかし、宣言を以下のようにすることで共変になる。

```scala
trait Queue[+T] { ... }
```
このように定義されている場合、Queue[String]はQueue[AnyRef]のサブ型になる。


また、```-T```と宣言することで**反変**となる。この場合、TがSのサブ型である場合、Queue[S]はQueue[T]のサブ型になる(待ち行列としてはおかしい挙動)。

このように、型パラメータを共変、反変、非変に指定することを**変位指定**といい、+,-のことを変位指定アノテーションと呼ぶ。

変位指定は、イミュータブルなクラスでは上記のように上手くいくが、ミュータブルだとまずいこともある。
例えば次のようなクラスを考える。
```scala
class Cell[+T](init: T) {
  private[this] var current = init
  def get = current
  def set(x: T) { current = x }
}
```
一見普通に作れそうであるが、これはコンパイルエラーとなる(setの行。ミュータブルな共変変数への再代入がダメ)。
もしこれが許されると、次のようなコードが書けてしまうためである、

```scala
val c1 = new Cell[String]("abc")
val c2: Cell[Any] = c1
c2.set(1)
val s: String = c1.get
```

## 変位指定と配列
Javaのいにしえの話なので軽めに。
Javaの配列は共編で、上のコードのようなことが実際にかけてしまうが代入時に例外。ジェネリクスがなかった頃の互換性のため。

Scalaではその問題を踏まえて、配列を非変として扱っている。
しかし、Javaで書かれたコードで共編的に扱わなければならないことがあるため、Array[String]はArray[Object]にキャストすることができる。この場合、代入時に例外が発生する上の問題と同じ危険性をはらんでいる。


# 変位指定アノテーションのチェック

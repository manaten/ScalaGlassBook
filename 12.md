# トレイト

## キーワード
- トレイト
  - mixin合成
- シンインタフェース・リッチインタフェース
- 型パラメータ
- 積み重ね可能な変更
- 線形化

# トレイト
トレイトは以下のようにして定義する。
```scala
trait Philosophical {
  def philosophize() {
    println("I consume memory, therefore I am!")
  }
}
```

 トレイトを利用するには、 **with** または **extends** キーワードを用いて、トレイトを **ミックスイン** する。

```scala
class Frog extends Philosophical {
  override def toString = "green"
}

val frog = new Frog
frog.philosophize()
```
Philosophicalトレイトの性質を継承しつつ、更にその親クラスであるAnyクラスのtoStringをオーバーライドしている。

トレイトは型の定義もする = Philosophical型の変数をつくれる(PHPのトレイトは無理)。
```scala
val phil: Philosophical = frog
phil.philosophize()
```

## withを使ったミックスイン
withキーワードを使えば、既に別のクラスのサブクラスであるクラスにミックスインできる。

```scala
class Animal
class Frog extends Animal with Philosophical {
  override def toString = "green"
}
```

複数のトレイトをミックスインすることもできる。

```scala
class Animal
tarit HasLegs
class Frog extends Animal with Philosophical with HasLegs {
  override def toString = "green"
}
```

## トレイトのメソッドのオーバーライド
トレイトで定義されたメソッドのオーバーライドもできる。
```scala
class Animal
class Frog extends Animal with Philosophical {
  override def toString = "green"
  override def philosophize() {
    println("It ain't easy being " toString + "!")
  }
}
```

このようにして定義したFrogのインスタンスは、もちろんPhilosophicalのインスタンスとして利用することができ、philosophizeの挙動も変わっている。
```scala
val phil: Philosophical = frog
phil.philosophize()
// It ain't easy being green!
```

## クラスとトレイトの違い

トレイトは具象メソッドを持つインタフェースのように思えるが、それ以上にできることが多く、次の二点を除いてクラスと同等のことができる。

### クラスパラメータを取ることができない
```scala
trait Hoge(x: Int) // 無理！
```

### superの束縛が動的
class宣言のsuperは自明に親クラスをたどればわかるが(静的)、trait宣言でのsuperは、traitがwithされるまでわからない(動的)。
```scala
trait Printable {
  def print = println(super.toString) // superはwithされて初めて分かる
}
```

# シンインタフェースとリッチインタフェース

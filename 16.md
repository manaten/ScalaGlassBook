# リストの操作

## キーワード
- List型
  - 連結リスト
  - イミュータブル
  - 等質的
  - 共編
  - コンス
- リストパターン
- 一階メソッド
- 高階メソッド
- 分割統治

# リストリテラル
```scala
val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val diag3 =
  List(
    List(1, 0, 1)
    List(0, 1, 0)
    List(0, 0, 1)
  )
val empty = List()
```
配列との違いは、
- リストはイミュータブルである
- リストは再帰的な構造(連結リスト)である
の二点である


# List型
- 配列と同様、等質的(List[T]の要素はすべてT型。)
- 共編。S型がT型のサブ型ならば、List[S]はList[T]のサブ型
- 空リストはList[Nothing]型であり、すべての型のリストに代入可能。

# リストの構築
リストは ```Nil```(空リスト) と ```::```(コンスと発音する)から組み立てられる。
```x :: xs``` は、先頭要素が ```x``` で、残りの要素が ```xs```。

先ほどのリスト構築は次のようにも書ける。
```scala
val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3 = (1 :: (0 :: (0 :: Nil))) ::
            (0 :: (1 :: (0 :: Nil))) ::
            (0 :: (0 :: (1 :: Nil))) :: Nil
val empty = Nil
```
```::``` 演算子は右結合なので、```val nums = 1 :: 2 :: 3 :: 4 :: Nil``` でよい。

# リストの基本操作
リストのすべての操作は以下の3つの操作で表現できる。
- **head** リストの先頭要素を返す
- **tail** 先頭要素を除く全ての要素から構成されるリストを返す
- **isEmpty** リストが空ならtrueを返す

headやtailは空でないリストのみで使用可能。空リストでは例外。

挿入ソートの例
```scala
def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))
def insert(x: Int, xs: List[Int]): List[Int] =
  if (xs.isEmpty || x <= xs.head) x :: xs
  else xs.head :: insert(x, xs.tail)

```

# リストパターン

リストはパターンマッチで分解可能。
```scala
val List(a, b, c) = fruit
a: String = apples
b: String = oranges
c: String = pears

val a :: b :: rest = fruit
a: String = apples
b: String = oranges
rest: List[String] = List(pears)
```

パターンはhead, tail, isEmptyの代替になる。
```scala
def isort(xs: List[Int]): List[Int] = xs match {
  case List() => List()
  case x :: xs1 => insert(x, isort(xs1))
}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() => List(x)
  case y :: ys = if (x <= y) x :: xs
                 else y :: insert(x, ys)
}
```
パターンマッチもリスト操作のための道具箱で、パターンマッチを用いたほうが直感的に記述できる場合も多い。

# Listクラスの一階メソッド

## リストの連結
```:::``` 演算子はリストの連結。右結合。

```scala
List(1, 2) ::: List(3, 4, 5)
// List[Int] = List(1, 2, 3, 4, 5)
```

## 分割統治原則
```:::``` を自分で実装する。

appendという名前で実装することにし、シグニチャを考える。型パラメータを用いると次のようになる。
```scala
def append[T](xs: List[T], ys: List[T]): List[T]
```

- パターンマッチを用いて入力を単純なケースに **分割**
- ここのケースごとに結果値を作ることを再帰的に呼び出し、結果を得る(**統治**)

今回は、第一引数 xsをysの頭にくっつけていくことを考える。
分割=パターンマッチは次のようになる。
```scala
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List()   => // ??
    case x :: xs1 => // ??
  }
```

空リストのケースはそのままysが結果値となれば良い。
そうでない場合は、xを先頭とし、残りはxs1とysの連結(すなわちappendの再帰的呼び出し)が結果値であればいい。
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List()   => ys
    case x :: xs1 => x :: append(xs1, ys)
  }
```

## リストの長さを計算する: length
```scala
List(1, 2, 3).length
// 3
```

リストの長さ計算は全体をたどる必要が有るため、配列の場合と比べてコストである。
要素があるか調べる場合は```isEmpty```を使うべきである。

## リスト末尾へのアクセス: initとlast
initは最後の要素を除く部分からなるリスト、lastは最後の要素を返す(head, tailの反対)。
```scala
val abcde = List('a', 'b', 'c', 'd', 'e')
abcde.last // e
abcde.init // List(a, b, c, d)
```
空リストに吾道して使うと例外。

これらはhead, tailとは違い、全部辿らないと計算出来ないメソッドである。


## リストの反転: reverse

リストの末尾に頻繁にアクセスする場合は、リストを反転して先頭にアクセスするほうが効率が良い。
```scala
abcde.reverse
// List[Char] = List(e, d, c, b, a)
```

reverse, init, lastはある種の法則を満足していて、これらは計算内容の推論や単純化に利用できる。

### reverseは自身の逆操作である。
```
xs.reverse.reverse equals xs
```

### reverseはinitをtailに、lastをheadにかえる。(ただし要素は逆順になっている)
```scala
xs.reverse.init equals xs.tail.reverse
xs.reverse.tail equals xs.init.reverse
xs.reverse.head equals xs.last
xs.reverse.last equals xs.head
```

```:::```を使ってreverseを実装できる。
```scala
def rev[T](xs: List[T]): List[T] = xs match {
  case List() => xs
  case x : xs1 => rev(xs1) ::: List(x)
}
```
このメソッドは効率的ではなく、revは再帰的にn回呼ばれる上に、末尾への要素追加も要素数nに比例したコストとなる。(o(n^2)である)

16.7節で高速化の方法を示す。

## プレフィクスとサフィックス: drop, take, splitAt
- ```xs take n``` 先頭からn個の要素を取り出したリストを返す
- ```xs drop n``` 先頭からn個の要素を取り除いたリストを返す

splitAtは、n個目でリストを分割し、分割したリストのペアを返す(ただし、二回リストをたどるような実装にはなっていない)。
```scala
xs splitAt n equals (xs take n, xs drop n)
```

```scala
abcde take 2 // List(a, b)
abcde drop 2 // List(c, d, e)
abcde splitAt 2 // (List(a, b), List(c, d, e))
```

## 要素の選択: applyとindice
ランダムアクセスにはapplyメソッドを使うが、リストでは配列ほどこのメソッドを使わない。
```scala
abcde apply 2 // c
abcde(2) // 短縮記法も可能
```

リストでランダムアクセスが好まれない理由は、連結リストでのランダムアクセスは要素数に比例した時間がかかるからであり、実際applyは次のように実装されている。

```scala
xs apply n equals (xs drop n).head
```

これは、配列と同様にリストの添字は0からn-1までであることも示している。

リストの添字のリストを得るメソッドとしてindicesがある。
```scala
abcde.indices // List(0, 1, 2, 3, 4)
```

## リストのジッパー操作: zip
2つのリストをジッパーで閉じるように、ペアのリストをつくる。相手のいない要素は捨てられる。
```scala
abcde.indices zip abcde // List((0, a), (1, b), (2, c), (3, d), (4, e))
abcde zip List(1, 2, 3) // List((1, a), (2, b), (3, c))
```
添字とリストのペアのリストを作る場合、```zipWithIndex```というメソッドもある。
```scala
abcde.zipWithIndex // List((0, a), (1, b), (2, c), (3, d), (4, e))
```

## リストの表示: toString, mkString
toSringメソッドはリストの標準的な文字列表現を返す。
``scala
abcde.toString  // String = List(a, b, c, d, e)
```
これとは別の表現が欲しい場合は```mkString```を使う。
```xs mkString(pre, sep, post)``` の3つの引数を取り、それぞれ接頭辞、セパレータ、接尾辞である。
mkStringメソッドは引数が省略できるよう、多重定義を持っている。

```scala
abcde mkString ("[", ",", "]") // [a,b,c,d,e]
abcde mkString "" // abcde
abcde.mkString // abcde
abcde.mkString ("List(", ", ", ")") // List(a, b, c, d, e)
```

変種として、StringBuilderに追加を行う```addString```もある。
```scala
val buf = new StringBuilder
abcde addString (buf, "(", ";", ")") // StringBuilder = (a;b;c;d;e)
```

mkString, addString はListのスーパートレイトであるIterableのメソッドなので、反復操作可能なコレクションすべてで利用可能である。

## リストの変換: elements, toArray, copyToArray
配列のフラットな世界とリストの再帰的な世界の間でデータ変換するには、List.toArrayやArray.toListを利用する。
```scala
val arr = abcde.toArray // Array(a, b, c, d, e)
arr.toString // String = Array(a, b, c, d, e)
arr.toList // List(a, b, c, d, e)
```

```copyToArray```メソッドでは、配列の任意の部分にリストの要素をコピーできる。
``scala
val arr = new Array[Int](10)
List(1, 2, 3) copyToArray (arr, 3)
arr.toString // Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)
```

イテレータを介してリストにアクセスする場合はelementsメソッドを用いる。
```scala
val it = abcde.elements // Iterator[Char]
it.next // a
it.next // b
```

## サンプル: マージソート

カリー化、分割統治のサンプル。
```scala
def msort[T](less: (T, T) => Boolean) (xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) => ys
      case (_, Nil) => xs
      case (x :: xs1, y :: ys1) =>
        if (less(x, y)) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
  val n = xs.length / 2
  if (n == 0) xs
  else {
    val (ys, zs) = xs splitAt n
    merge(msort(less)(ys), msort(less)(zs))
  }
}
```

計算量は nLog(n) となる。再起の回数はLog(n)回、各再起レベルで、各要素がマージ処理を行うため、各再起レベルはnに比例したコストとなるため。

msortは次のように使う。
```scala
msort((x: Int, y: Int) => x < y)(List(5, 7, 1, 3))
// List(1, 3, 5, 7)
```

カリー化された関数であるので、特化したソート関数を作ることもできる。
```scala
val intSort = msort((x: Int, y: Int) => x < y) _
// intSort: (List[Int]) => List[Int] = <function>
```
intSortは整数リストを昇順にソートする特化関数である。

降順ソートする関数も作れる。
```scala
val reverseIntSort = msort((x: Int, y: Int) => x > y) _
// reverseIntSort: (List[Int]) => List[Int] = <function>
```

これらは以下のように利用可能である。
```scala
val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
intSort(mixedInts) // List(0, 1, 2, 3, 4, 5, 6, 7, 8 ,9)
reverseIntSort(mixedInts) // List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
```

# Listクラスの高階メソッド

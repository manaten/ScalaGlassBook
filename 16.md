# リストの操作

## キーワード
- List型
  - 連結リスト
  - イミュータブル
  - 等質的
  - 共編
  - コンス
- リストパターン
- 一階メソッド
- 高階メソッド

# リストリテラル
```scala
val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val diag3 =
  List(
    List(1, 0, 1)
    List(0, 1, 0)
    List(0, 0, 1)
  )
val empty = List()
```
配列との違いは、
- リストはイミュータブルである
- リストは再帰的な構造(連結リスト)である
の二点である


# List型
- 配列と同様、等質的(List[T]の要素はすべてT型。)
- 共編。S型がT型のサブ型ならば、List[S]はList[T]のサブ型
- 空リストはList[Nothing]型であり、すべての型のリストに代入可能。

# リストの構築
リストは ```Nil```(空リスト) と ```::```(コンスと発音する)から組み立てられる。
```x :: xs``` は、先頭要素が ```x``` で、残りの要素が ```xs```。

先ほどのリスト構築は次のようにも書ける。
```scala
val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3 = (1 :: (0 :: (0 :: Nil))) ::
            (0 :: (1 :: (0 :: Nil))) ::
            (0 :: (0 :: (1 :: Nil))) :: Nil
val empty = Nil
```
```::``` 演算子は右結合なので、```val nums = 1 :: 2 :: 3 :: 4 :: Nil``` でよい。

# リストの基本操作
リストのすべての操作は以下の3つの操作で表現できる。
- **head** リストの先頭要素を返す
- **tail** 先頭要素を除く全ての要素から構成されるリストを返す
- **isEmpty** リストが空ならtrueを返す

headやtailは空でないリストのみで使用可能。空リストでは例外。

挿入ソートの例
```scala
def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))
def insert(x: Int, xs: List[Int]): List[Int] =
  if (xs.isEmpty || x <= xs.head) x :: xs
  else xs.head :: insert(x, xs.tail)

```

# リストパターン

リストはパターンマッチで分解可能。
```scala
val List(a, b, c) = fruit
a: String = apples
b: String = oranges
c: String = pears

val a :: b :: rest = fruit
a: String = apples
b: String = oranges
rest: List[String] = List(pears)
```

パターンはhead, tail, isEmptyの代替になる。
```scala
def isort(xs: List[Int]): List[Int] = xs match {
  case List() => List()
  case x :: xs1 => insert(x, isort(xs1))
}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() => List(x)
  case y :: ys = if (x <= y) x :: xs
                 else y :: insert(x, ys)
}
```
パターンマッチもリスト操作のための道具箱で、パターンマッチを用いたほうが直感的に記述できる場合も多い。

# Listクラスの一階メソッド

## リストの連結
```:::``` 演算子はリストの連結。右結合。

```scala
List(1, 2) ::: List(3, 4, 5)
// List[Int] = List(1, 2, 3, 4, 5)
```

## 分割統治原則
```:::``` を自分で実装する。

appendという名前で実装することにし、シグニチャを考える。型パラメータを用いると次のようになる。
```scala
def append[T](xs: List[T], ys: List[T]): List[T]
```

- パターンマッチを用いて入力を単純なケースに **分割**
- ここのケースごとに結果値を作ることを再帰的に呼び出し、結果を得る(**統治**)

今回は、第一引数 xsをysの頭にくっつけていくことを考える。
分割=パターンマッチは次のようになる。
```scala
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List()   => // ??
    case x :: xs1 => // ??
  }
```

空リストのケースはそのままysが結果値となれば良い。
そうでない場合は、xを先頭とし、残りはxs1とysの連結(すなわちappendの再帰的呼び出し)が結果値であればいい。
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List()   => ys
    case x :: xs1 => x :: append(xs1, ys)
  }
```

## リストの長さを計算する: length
```scala
List(1, 2, 3).length
// 3
```

リストの長さ計算は全体をたどる必要が有るため、配列の場合と比べてコストである。
要素があるか調べる場合は```isEmpty```を使うべきである。


